# 今日重点
  对数据进行增删改查
## jQ设置和获取缓存数据
```js
语法：
	 jq对象.data('属性名')   		---> 获取

     jq对象.data('属性名','值')      ---> 设置

本质：
     jQ对象.data() 方法也是在操作自定义属性，将数据保存到了缓存中，没有在标签上体现出来。
```
## jQ遍历
```js

语法2：
    $.each(object, function(index, element){})

备注：
   	1. object表示要遍历哪个对象，一般在程序是一个数据【数组，对象】
    2. index，表示数据的索引值
    3. element 表示数据中的值

区别：

     1. $.each()        去遍历数据，一般情况下用来遍历数组（也可以遍历jQ对象）

     2. jQ对象.each()    去遍历数据，一般情况下就是用来去遍历jQ对


例如：

	 //遍历程序中的数据
	 var ary = ['a','b', 'c'];
	 $.each(ary, function(i,element) {
         console.log(i, element);
     })
     //可以遍历程序中的jq对象
     $.each($('li'), function(i, element){
         console.log(i, element);
     })

```
## JQ获取元素大小和位置
```js 

    ☞ 获取元素大小方法如下：

        1. jQ对象.width() | jQ对象.height()     ----> 获取元素的内容区域大小

        2. jQ对象.innerWidth() | jQ对象.innerHeight()   ---> 获取元素大小（内容区域+内边距）

        3. jQ对象.outerWidth() | jQ对象.outerHeight()  --->获取元素大小（内容区域 + 边框 + 内边距）

        4. jQ对象.outerWidth(true)  | jQ对象.outerHeight(true)  ----> 获取元素大小（内容区域 + 边框 + 内边距 + 外边距）


        注意：
             1. 如果要通过  width() 设置值，  写法：  JQ对象.width(值)

             2. 在设置值的时候，不需要加单位

    ☞ 获取元素位置如下：

        1. jQ对象.offset()  

            ☞ 得到是一个对象

            ☞ left：   top：


            ☞ 总结：
                 通过offset()得到元素的位置，与其父元素无关，通过offset()获取的是当前元素相对整个文档（页面）

               
                例如：
                $('.one').offset().top

        2. jQ对象.position()

             ☞ 得到是一个对象

             ☞ left | top

             ☞ 总结：
                 
                 通过 position()获取元素位置的时候，如果当前父元素没有定位，那么就参照整个页面，如果当前父元素有定位，那么就直接参照父元素（类似于CSS中的绝对定位）


                 例如：
                   $('.one').position().top

        3. jQ对象.scrollTop();

             ☞ scrollTop() 用来获取内容区域（元素）滚动出去的距离

             ☞ 如果希望通过程序的方式获取元素滚动出去的距离，那么需要在 scroll事件中获取

             ☞ 该方法返回的就是一个滚动出去的距离具体值

```
## jQ注册事件
```js

    1. 常规方式通过： 事件源.事件类型(function(){});

        例如： $('div').click(function(){})

        特点： 
             给事件元素绑定一个事件

    2. 通过on的方式：

          事件源.on(事件类型, function(){})    ---> 绑定一个事件

          事件源.on({                         ---> 绑定多个事件
              事件类型: function(){},
              事件类型: function(){},
              事件类型: function(){}
              ...
          })

          事件源.on('事件类型  事件类型', function(){})  ---> 绑定多个事件，多个事件执行的是相同的代码

    3. 通过on的方式实现委托思想

         事件源.on('事件类型', '选择器', function(){});

         注意：
             ✔ 如果元素是动态创建的，那么动态给该元素注册事件就需要是使用on的委托方式
```
## jQ解绑事件
```js


    语法：
        jQ对象.off()


    总结：
         1. 如果off()方法中没有设置任何参数，那么代表将该对象中的所有事件都解绑掉
         2. 如果要通过off()方法移除对应的事件，那么在参数中设置对应事件的名称即可。 

            例如: $('div').off('click');

         3. 如果要将委托事件解绑那么可以按照如下写法：

            例如：
             //解绑委托事件
             $('父事件源').off('事件类型', '选择器');


         4. 可以给元素通过 one() 方法给元素注册事件，只能执行一次

             例如：
              $('div').one('click', function(){
                    alert(123);
              })

```
## jQ自动触发事件
```js

    第一种方式：

        事件源.事件类型();


    第二种方式：

        事件源.trigger('事件类型');


        例如：

         $('div').click(function(){
              alert(1);
         })


        $('div').trigger('click');

```
## 事件对象参数
```js
   事件对象参数操作方式与原生dom操作方式一样。
```
## 其他部分
```js
    1. 拷贝对象

        语法：
            $.extend([deep], targetObject, currentObject)

        参数介绍：

             1. deep，布尔类型的值。 默认值是false, 该参数用来设定拷贝对象的时候是深拷贝还是浅拷贝

                如果deep的值是默认值，代表的是浅拷贝

                如果deep的值是true，代表的是深拷贝

                总结：  

                    1. 不管是浅拷贝还是深拷贝，如果原来对象中有一个和被拷贝对象中相同的属性，会被覆盖掉。

                    2. 不管是浅拷贝还是深拷贝, 如果原来对象中不存在与被拷贝对象相同的属性，不会被覆盖掉。

                    3. 如果是浅拷贝，那么在拷贝过程中如果遇到是对象，那么是将对象的地址赋值给目标对象

                    4. 如果是深拷贝， 那么在拷贝的过程中，是直接将对象复制一份拷贝给目标对象

             2. targetObject 用来接收拷贝的对象

             3. currentObject 要被拷贝的对象


    2. 多库共存: 为了避免其他js文件中的命名和Jquery中的 $ 命名冲突
         
         ☞ 将 $ 用 jQuery 替换
         ☞ 通过自定义的方式实现
         var  自定义一个变量  = jQuery.noConflict();

            自定义一个变量('div')...

    3. 插件介绍:

        ☞ 全屏滚动插件

        ☞ 懒加载插件



        插件使用步骤一般注意事项：

              1. 必须先引用jQ文件
              2. 然后再引用当前的插件对应的js文件
```
## 综合案例


